___________________________________________
		
		Version 1
___________________________________________

for version one since we have to generate and print all permutations the big O notation
of the written method is O(m*n!) n! reffering to the number of generated permutation
from the recursive call where n would is the length of the given short String
and mulitplied by m which is the worst case of the loop that checks for the match for
each permutation. This method is not scalable at all since just at short String of length 7
the number of permutations start to get out of hand and the factorial function becomes
large to rapidly as seen in the out.txt file.

O(m*n!)

___________________________________________
		
		Version 1
___________________________________________

for version two all we do is use the built in sort method on the short 
String and a certain substring of the long String generated by a loop
the buuilt in java sort method has a time complexity of nlog(n) and since it has to be
nested in a loop that is related to the length of the long String m
the time complexity is O(m*nlogn). This function is definitely scalable with bigger data
since we don't have to print every permutation unless there is a match we can use the sort
method to write a more efficent algorithm that will still give us the usefull information.

O(m*nlogn)

_____________________________________________
comment:

Since we are not creating any variables in the process or adding anything to the memory
dynamically the space complexity is O(1) for everything